<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Pose Detection</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #000;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        /* 캔버스와 비디오를 겹쳐서 배치 */
        .container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        video {
            position: absolute;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1); /* 거울 모드 */
            z-index: 1;
        }
        canvas {
            position: absolute;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1); /* 거울 모드 */
            z-index: 2;
        }
        #status {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 3;
            color: white;
            font-size: 1.2rem;
            background: rgba(0,0,0,0.5);
            padding: 10px;
            border-radius: 8px;
        }
    </style>
    <!-- MediaPipe 라이브러리 로드 -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose/pose.js" crossorigin="anonymous"></script>
</head>
<body>
    <div class="container">
        <video id="input_video" playsinline></video>
        <canvas id="output_canvas"></canvas>
        <div id="status">로딩중...</div>
    </div>

    <script>
        const videoElement = document.getElementById('input_video');
        const canvasElement = document.getElementById('output_canvas');
        const canvasCtx = canvasElement.getContext('2d');
        const statusDiv = document.getElementById('status');

        // 각도 계산 함수 (세 점 사이의 각도)
        function calculateAngle(a, b, c) {
            const radians = Math.atan2(c.y - b.y, c.x - b.x) - Math.atan2(a.y - b.y, a.x - b.x);
            let angle = Math.abs(radians * 180.0 / Math.PI);
            if (angle > 180.0) angle = 360 - angle;
            return angle;
        }

        function onResults(results) {
            // 캔버스 크기를 비디오 크기에 맞춤
            canvasElement.width = videoElement.videoWidth;
            canvasElement.height = videoElement.videoHeight;

            canvasCtx.save();
            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);

            // 1. 이미지는 그리지 않고 투명하게 (카메라 영상 위에 선만 그리기 위함)
            // 원한다면 아래 주석을 풀어 비디오 원본을 캔버스에 그릴 수 있습니다.
            // canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);

            if (results.poseLandmarks) {
                const landmarks = results.poseLandmarks;

                // 랜드마크 인덱스 (MediaPipe Pose 기준)
                // 11: 왼쪽 어깨, 12: 오른쪽 어깨
                // 13: 왼쪽 팔꿈치, 14: 오른쪽 팔꿈치
                // 15: 왼쪽 손목, 16: 오른쪽 손목
                // 23: 왼쪽 엉덩이, 24: 오른쪽 엉덩이
                // 25: 왼쪽 무릎, 26: 오른쪽 무릎
                // 27: 왼쪽 발목, 28: 오른쪽 발목

                // 1. 팔 펴짐 확인 (어깨-팔꿈치-손목 각도)
                const leftArmAngle = calculateAngle(landmarks[11], landmarks[13], landmarks[15]);
                const rightArmAngle = calculateAngle(landmarks[12], landmarks[14], landmarks[16]);
                
                const isLeftArmStraight = leftArmAngle > 160;
                const isRightArmStraight = rightArmAngle > 160;

                // 2. 몸 펴짐 확인 (어깨-엉덩이-무릎 각도 AND 엉덩이-무릎-발목 각도)
                // 왼쪽 몸
                const leftBodyAngle1 = calculateAngle(landmarks[11], landmarks[23], landmarks[25]); 
                const leftBodyAngle2 = calculateAngle(landmarks[23], landmarks[25], landmarks[27]);
                // 오른쪽 몸
                const rightBodyAngle1 = calculateAngle(landmarks[12], landmarks[24], landmarks[26]);
                const rightBodyAngle2 = calculateAngle(landmarks[24], landmarks[26], landmarks[28]);

                // 서 있는 상태: 엉덩이와 무릎이 거의 펴져 있어야 함
                const isBodyStraight = (leftBodyAngle1 > 160 && leftBodyAngle2 > 160) || 
                                       (rightBodyAngle1 > 160 && rightBodyAngle2 > 160);

                // 조건 검사: 몸이 1자이거나, 팔 중 하나가 1자인 경우
                let color = '#FF0000'; // 기본값: 빨강
                let message = "자세를 취해주세요";

                if (isBodyStraight) {
                    color = '#00FF00'; // 초록
                    message = "몸이 1자입니다! (초록)";
                } else if (isLeftArmStraight || isRightArmStraight) {
                    color = '#00FF00'; // 초록
                    message = "팔이 펴졌습니다! (초록)";
                }

                statusDiv.innerText = message;
                statusDiv.style.color = color;

                // 스켈레톤 그리기
                drawConnectors(canvasCtx, results.poseLandmarks, POSE_CONNECTIONS,
                             {color: color, lineWidth: 4});
                drawLandmarks(canvasCtx, results.poseLandmarks,
                            {color: color, lineWidth: 2, radius: 4});
            }
            canvasCtx.restore();
        }

        const pose = new Pose({locateFile: (file) => {
            return `https://cdn.jsdelivr.net/npm/@mediapipe/pose/${file}`;
        }});

        pose.setOptions({
            modelComplexity: 1, // 0: 빠름, 1: 보통, 2: 정확함 (모바일은 1 추천)
            smoothLandmarks: true,
            enableSegmentation: false,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });

        pose.onResults(onResults);

        const camera = new Camera(videoElement, {
            onFrame: async () => {
                await pose.send({image: videoElement});
            },
            width: 1280,
            height: 720
        });

        // 카메라 시작
        camera.start().then(() => {
            statusDiv.innerText = "카메라 시작됨";
        }).catch(err => {
            statusDiv.innerText = "카메라 오류: " + err;
        });
    </script>
</body>
</html>