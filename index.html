<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Stickman Pose Audio</title>
    <style>
        body { margin: 0; padding: 0; background-color: #000; overflow: hidden; display: flex; justify-content: center; align-items: center; font-family: 'Courier New', Courier, monospace; }
        .container { position: relative; width: 100vw; height: 100vh; }
        video, canvas { position: absolute; left: 0; top: 0; width: 100%; height: 100%; object-fit: cover; }
        .mirror { transform: scaleX(-1); }
        .normal { transform: scaleX(1); }
        video { z-index: 1; }
        canvas { z-index: 2; }
        #status-box { position: absolute; top: 20px; left: 50%; transform: translateX(-50%); z-index: 3; width: 90%; text-align: center; pointer-events: none; }
        #message { background: rgba(0, 0, 0, 0.9); color: white; padding: 15px; border: 2px solid #FF0000; font-size: 1rem; font-weight: bold; text-transform: uppercase; transition: all 0.2s; }
        #debug { margin-top: 5px; font-size: 0.8rem; color: #ccc; background: black; display: inline-block; padding: 2px 5px; }
        #switch-btn { position: absolute; bottom: 30px; right: 20px; z-index: 4; background-color: #333; color: white; border: 2px solid white; padding: 15px 20px; font-family: inherit; font-weight: bold; font-size: 1rem; cursor: pointer; }
        #switch-btn:active { background-color: white; color: black; }
        #start-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); z-index: 10; display: flex; flex-direction: column; justify-content: center; align-items: center; color: white; cursor: pointer; }
        #start-btn { border: 2px solid #00FF00; padding: 20px; margin-top: 20px; font-size: 1.5rem; color: #00FF00; }
    </style>
    <!-- MediaPipe -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose/pose.js" crossorigin="anonymous"></script>
</head>
<body>
    <div class="container">
        <video id="input_video" class="mirror" playsinline autoplay muted></video>
        <canvas id="output_canvas" class="mirror"></canvas>
        <div id="status-box">
            <div id="message">WAITING FOR CAMERA...</div>
            <div id="debug"></div>
        </div>
        <button id="switch-btn">CAM SWITCH</button>
        <div id="start-overlay">
            <div>TOUCH TO START</div>
            <div id="start-btn">START</div>
        </div>
    </div>

    <script>
        const videoElement = document.getElementById('input_video');
        const canvasElement = document.getElementById('output_canvas');
        const canvasCtx = canvasElement.getContext('2d');
        const messageDiv = document.getElementById('message');
        const debugDiv = document.getElementById('debug');
        const switchBtn = document.getElementById('switch-btn');
        const startOverlay = document.getElementById('start-overlay');

        let successAudio = null;
        let wasSuccessLastFrame = false;
        let isFrontCamera = true;
        let currentStream = null;
        let pose = null;
        let isRunning = false;

        let activeBeams = [];
        const BEAM_SPEED = 30;
        const BEAM_LENGTH = 150;
        const BEAM_COLOR = "white";
        const BEAM_WIDTH = 8;
        let wasLeftArmReadyToFire = false;
        let wasRightArmReadyToFire = false;

        function toPixel(landmark, width, height) { return landmark ? { x: landmark.x * width, y: landmark.y * height, visibility: landmark.visibility } : null; }
        function calculateAngle(a, b, c) { if(!a||!b||!c) return 0; const rad = Math.atan2(c.y - b.y, c.x - b.x) - Math.atan2(a.y - b.y, a.x - b.x); let angle = Math.abs(rad * 180.0 / Math.PI); return angle > 180.0 ? 360 - angle : angle; }
        function calculateVerticalDeviation(a, b) { if(!a||!b) return 90; const dx = Math.abs(b.x - a.x); const dy = Math.abs(b.y - a.y); return Math.atan2(dx, dy) * 180.0 / Math.PI; }
        function calculateHorizontalDeviation(a, b) { if(!a||!b) return 90; const dy = b.y - a.y; const dx = b.x - a.x; let angle = Math.abs(Math.atan2(dy, dx) * 180.0 / Math.PI); return angle > 90 ? Math.abs(180 - angle) : angle; }
        function getDistance(p1, p2) { if (!p1 || !p2) return Infinity; return Math.hypot(p1.x - p2.x, p1.y - p2.y); }
        function getNormalizedScore(current, good, bad, isAngle = false) { if (isAngle) { if (current >= good) return 1.0; if (current <= bad) return 0.0; return (current - bad) / (good - bad); } else { if (current <= good) return 1.0; if (current >= bad) return 0.0; return 1.0 - ((current - good) / (bad - good)); } }

        function drawLine(ctx, p1, p2, color, width) { if (!p1 || !p2 || p1.visibility < 0.5 || p2.visibility < 0.5) return; ctx.beginPath(); ctx.moveTo(p1.x, p1.y); ctx.lineTo(p2.x, p2.y); ctx.strokeStyle = color; ctx.lineWidth = width; ctx.stroke(); }
        
        function drawStickFigure(ctx, p, color) {
            const lineWidth = 6;
            if (p[11] && p[12] && p[23] && p[24]) {
                const shoulderMid = { x: (p[11].x + p[12].x) / 2, y: (p[11].y + p[12].y) / 2, visibility: (p[11].visibility + p[12].visibility) / 2 };
                const hipMid = { x: (p[23].x + p[24].x) / 2, y: (p[23].y + p[24].y) / 2, visibility: (p[23].visibility + p[24].visibility) / 2 };
                drawLine(ctx, shoulderMid, hipMid, color, lineWidth);
                if (p[0]) drawLine(ctx, shoulderMid, p[0], color, lineWidth);
            }
            drawLine(ctx, p[11], p[12], color, lineWidth); drawLine(ctx, p[23], p[24], color, lineWidth);
            drawLine(ctx, p[11], p[13], color, lineWidth); drawLine(ctx, p[13], p[15], color, lineWidth);
            drawLine(ctx, p[12], p[14], color, lineWidth); drawLine(ctx, p[14], p[16], color, lineWidth);
            
            // 손 그리기 (Pose 모델이 제공하는 최대 정보)
            drawLine(ctx, p[15], p[17], color, lineWidth); // Left Wrist to Pinky
            drawLine(ctx, p[15], p[19], color, lineWidth); // Left Wrist to Index
            drawLine(ctx, p[15], p[21], color, lineWidth); // Left Wrist to Thumb
            drawLine(ctx, p[16], p[18], color, lineWidth); // Right Wrist to Pinky
            drawLine(ctx, p[16], p[20], color, lineWidth); // Right Wrist to Index
            drawLine(ctx, p[16], p[22], color, lineWidth); // Right Wrist to Thumb

            drawLine(ctx, p[23], p[25], color, lineWidth); drawLine(ctx, p[25], p[27], color, lineWidth);
            drawLine(ctx, p[24], p[26], color, lineWidth); drawLine(ctx, p[26], p[28], color, lineWidth);
        }

        // [UPDATED] 레이저 처리 함수 (Glow 효과 추가)
        function handleBeams(ctx, width, height) {
            ctx.save(); // 현재 그리기 상태 저장
            ctx.strokeStyle = BEAM_COLOR;
            ctx.lineWidth = BEAM_WIDTH;
            ctx.shadowColor = BEAM_COLOR; // 빛 번짐 색상
            ctx.shadowBlur = 15;          // 빛 번짐 강도

            activeBeams.forEach(beam => {
                beam.x += beam.direction * BEAM_SPEED;
                ctx.beginPath();
                ctx.moveTo(beam.x, beam.y);
                ctx.lineTo(beam.x + beam.direction * BEAM_LENGTH, beam.y);
                ctx.stroke();
            });

            ctx.restore(); // 저장했던 그리기 상태 복원 (빛 번짐 효과 제거)

            activeBeams = activeBeams.filter(beam => {
                const endX = beam.x + beam.direction * BEAM_LENGTH;
                return (beam.direction === 1) ? beam.x < width : endX > 0;
            });
        }

        function onResults(results) {
            if (!isRunning) return;
            const width = videoElement.videoWidth; const height = videoElement.videoHeight;
            canvasElement.width = width; canvasElement.height = height;
            canvasCtx.save();
            canvasCtx.clearRect(0, 0, width, height);
            
            handleBeams(canvasCtx, width, height);

            if (results.poseLandmarks) {
                const p = {};
                results.poseLandmarks.forEach((lm, idx) => p[idx] = toPixel(lm, width, height));

                const BODY_TILT_LIMIT = 5, ARM_HORIZON_LIMIT = 15, ELBOW_STRAIGHT_MIN = 165, KNEE_STRAIGHT_MIN = 170;
                const BODY_TILT_BAD = 20, ARM_HORIZON_BAD = 45, ELBOW_STRAIGHT_BAD = 130, KNEE_STRAIGHT_BAD = 140;

                const lTorso = calculateVerticalDeviation(p[11], p[23]), lLeg = calculateVerticalDeviation(p[23], p[27]);
                const lKnee = calculateAngle(p[23], p[25], p[27]);
                const rTorso = calculateVerticalDeviation(p[12], p[24]), rLeg = calculateVerticalDeviation(p[24], p[28]);
                const rKnee = calculateAngle(p[24], p[26], p[28]);
                const lElbow = calculateAngle(p[11], p[13], p[15]), rElbow = calculateAngle(p[12], p[14], p[16]);
                const lHorizon = calculateHorizontalDeviation(p[11], p[15]), rHorizon = calculateHorizontalDeviation(p[12], p[16]);

                const leftBodyOk = (lTorso < BODY_TILT_LIMIT) && (lLeg < BODY_TILT_LIMIT) && (lKnee > KNEE_STRAIGHT_MIN);
                const rightBodyOk = (rTorso < BODY_TILT_LIMIT) && (rLeg < BODY_TILT_LIMIT) && (rKnee > KNEE_STRAIGHT_MIN);
                const leftArmOk = (lElbow > ELBOW_STRAIGHT_MIN) && (lHorizon < ARM_HORIZON_LIMIT);
                const rightArmOk = (rElbow > ELBOW_STRAIGHT_MIN) && (rHorizon < ARM_HORIZON_LIMIT);
                
                const isBodyReady = leftBodyOk || rightBodyOk;
                const isArmReady = leftArmOk || rightArmOk;

                if (p[0] && p[11] && p[12] && p[15] && p[16]) {
                    const shoulderWidth = getDistance(p[11], p[12]);
                    const isLeftArmCurrentlyReady = (lElbow < ELBOW_STRAIGHT_BAD) && (getDistance(p[15], p[0]) < shoulderWidth * 1.2);
                    if (wasLeftArmReadyToFire && leftArmOk && leftBodyOk) {
                        // [UPDATED] 레이저 발사 위치를 어깨로 변경
                        activeBeams.push({ x: p[11].x, y: p[11].y, direction: isFrontCamera ? -1 : 1 });
                    }
                    wasLeftArmReadyToFire = isLeftArmCurrentlyReady;

                    const isRightArmCurrentlyReady = (rElbow < ELBOW_STRAIGHT_BAD) && (getDistance(p[16], p[0]) < shoulderWidth * 1.2);
                    if (wasRightArmReadyToFire && rightArmOk && rightBodyOk) {
                         // [UPDATED] 레이저 발사 위치를 어깨로 변경
                        activeBeams.push({ x: p[12].x, y: p[12].y, direction: isFrontCamera ? 1 : -1 });
                    }
                    wasRightArmReadyToFire = isRightArmCurrentlyReady;
                }

                const lBodyS = Math.min(getNormalizedScore(lTorso, BODY_TILT_LIMIT, BODY_TILT_BAD), getNormalizedScore(lLeg, BODY_TILT_LIMIT, BODY_TILT_BAD), getNormalizedScore(lKnee, KNEE_STRAIGHT_MIN, KNEE_STRAIGHT_BAD, true));
                const lArmS = Math.min(getNormalizedScore(lHorizon, ARM_HORIZON_LIMIT, ARM_HORIZON_BAD), getNormalizedScore(lElbow, ELBOW_STRAIGHT_MIN, ELBOW_STRAIGHT_BAD, true));
                const rBodyS = Math.min(getNormalizedScore(rTorso, BODY_TILT_LIMIT, BODY_TILT_BAD), getNormalizedScore(rLeg, BODY_TILT_LIMIT, BODY_TILT_BAD), getNormalizedScore(rKnee, KNEE_STRAIGHT_MIN, KNEE_STRAIGHT_BAD, true));
                const rArmS = Math.min(getNormalizedScore(rHorizon, ARM_HORIZON_LIMIT, ARM_HORIZON_BAD), getNormalizedScore(rElbow, ELBOW_STRAIGHT_MIN, ELBOW_STRAIGHT_BAD, true));
                const progressScore = Math.max(Math.min(lBodyS, lArmS), Math.min(rBodyS, rArmS));

                const isSuccess = isBodyReady && isArmReady;
                let color, failReason = "";
                if (!isBodyReady) failReason = "BODY TILT DETECTED"; else if (!isArmReady) failReason = "ARM NOT HORIZONTAL";

                if (isSuccess) {
                    color = "#00FF00"; messageDiv.innerText = "SUCCESS"; messageDiv.style.borderColor = color; messageDiv.style.color = color;
                    if (!wasSuccessLastFrame && successAudio) {
                        successAudio.currentTime = 0;
                        successAudio.play().catch(e => console.error("Audio play failed:", e));
                    }
                } else {
                    const white = Math.floor(255 * progressScore); color = `rgb(255, ${white}, ${white})`;
                    messageDiv.innerText = failReason || "STAND STRAIGHT"; messageDiv.style.borderColor = color; messageDiv.style.color = "#FFFFFF";
                }
                debugDiv.innerText = `POSE ACCURACY: ${(progressScore * 100).toFixed(0)}%`;
                wasSuccessLastFrame = isSuccess;
                drawStickFigure(canvasCtx, p, color);

            } else {
                messageDiv.innerText = "NO PERSON DETECTED"; messageDiv.style.borderColor = "#FF0000"; messageDiv.style.color = "#FFFFFF"; debugDiv.innerText = "";
                wasSuccessLastFrame = false; wasLeftArmReadyToFire = false; wasRightArmReadyToFire = false;
            }
            canvasCtx.restore();
        }

        async function setupCamera() { if (currentStream) currentStream.getTracks().forEach(track => track.stop()); const constraints = { video: { width: { ideal: 1280 }, height: { ideal: 720 }, facingMode: isFrontCamera ? 'user' : 'environment' }, audio: false }; try { const stream = await navigator.mediaDevices.getUserMedia(constraints); currentStream = stream; videoElement.srcObject = stream; videoElement.className = isFrontCamera ? 'mirror' : 'normal'; canvasElement.className = isFrontCamera ? 'mirror' : 'normal'; return new Promise((resolve) => { videoElement.onloadedmetadata = () => { resolve(videoElement); }; }); } catch (err) { alert("Camera Error: " + err.message); } }
        async function renderFrame() { if (isRunning && !videoElement.paused && !videoElement.ended) { await pose.send({ image: videoElement }); } requestAnimationFrame(renderFrame); }
        async function initPose() { messageDiv.innerText = "LOADING MODEL..."; pose = new Pose({ locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/pose/${file}` }); pose.setOptions({ modelComplexity: 1, smoothLandmarks: true, enableSegmentation: false, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 }); pose.onResults(onResults); await setupCamera(); videoElement.play(); renderFrame(); messageDiv.innerText = "READY"; }
        startOverlay.addEventListener('click', () => {
            if (!successAudio) {
                successAudio = new Audio('success.mp3');
                successAudio.load();
            }
            startOverlay.style.display = 'none';
            isRunning = true;
            initPose();
        });
        switchBtn.addEventListener('click', async () => { isFrontCamera = !isFrontCamera; switchBtn.innerText = "LOADING..."; await setupCamera(); videoElement.play(); switchBtn.innerText = "CAM SWITCH"; });
    </script>
</body>
</html>
