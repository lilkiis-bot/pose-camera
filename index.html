<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Stickman Pose & Hand Audio</title>
    <style>
        body { margin: 0; padding: 0; background-color: #000; overflow: hidden; display: flex; justify-content: center; align-items: center; font-family: 'Courier New', Courier, monospace; }
        .container { position: relative; width: 100vw; height: 100vh; }
        video, canvas { position: absolute; left: 0; top: 0; width: 100%; height: 100%; object-fit: cover; }
        .mirror { transform: scaleX(-1); }
        .normal { transform: scaleX(1); }
        video { z-index: 1; }
        canvas { z-index: 2; }
        #status-box { position: absolute; top: 20px; left: 50%; transform: translateX(-50%); z-index: 3; width: 90%; text-align: center; pointer-events: none; }
        #message { background: rgba(0, 0, 0, 0.9); color: white; padding: 15px; border: 2px solid #FF0000; font-size: 1rem; font-weight: bold; text-transform: uppercase; transition: all 0.2s; }
        #debug { margin-top: 5px; font-size: 0.8rem; color: #ccc; background: black; display: inline-block; padding: 2px 5px; }
        #switch-btn { position: absolute; bottom: 30px; right: 20px; z-index: 4; background-color: #333; color: white; border: 2px solid white; padding: 15px 20px; font-family: inherit; font-weight: bold; font-size: 1rem; cursor: pointer; }
        #switch-btn:active { background-color: white; color: black; }
        #start-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); z-index: 10; display: flex; flex-direction: column; justify-content: center; align-items: center; color: white; cursor: pointer; }
        #start-btn { border: 2px solid #00FF00; padding: 20px; margin-top: 20px; font-size: 1.5rem; color: #00FF00; }
    </style>
    <!-- MediaPipe -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose/pose.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>
    <div class="container">
        <video id="input_video" class="mirror" playsinline autoplay muted></video>
        <canvas id="output_canvas" class="mirror"></canvas>
        <div id="status-box">
            <div id="message">WAITING FOR CAMERA...</div>
            <div id="debug"></div>
        </div>
        <button id="switch-btn">CAM SWITCH</button>
        <div id="start-overlay">
            <div>TOUCH TO START</div>
            <div id="start-btn">START</div>
        </div>
    </div>

    <script>
        const videoElement = document.getElementById('input_video');
        const canvasElement = document.getElementById('output_canvas');
        const canvasCtx = canvasElement.getContext('2d');
        const messageDiv = document.getElementById('message');
        const debugDiv = document.getElementById('debug');
        const switchBtn = document.getElementById('switch-btn');
        const startOverlay = document.getElementById('start-overlay');
        const drawingUtils = window;

        // 오디오 및 모델 객체
        let successAudio, pullingAudio, shootAudio;
        let pose = null, hands = null;

        // [RESTRUCTURED] 상태 변수들
        let isRunning = false;
        let isFrontCamera = true;
        let lastPoseResults = null; // Pose 결과를 저장할 변수
        let lastHandResults = null; // Hands 결과를 저장할 변수
        let lastFrameState = {
            isSuccess: false,
            prevLeftElbowPos: null, prevRightElbowPos: null,
            wasLeftFist: false, wasRightFist: false
        };

        // 상수
        const ELBOW_MOVE_THRESHOLD = 3; // px
        const ELBOW_BENT_ANGLE = 130;

        // 유틸리티 함수
        function toPixel(landmark, width, height) { return landmark ? { x: landmark.x * width, y: landmark.y * height, visibility: landmark.visibility } : null; }
        function calculateAngle(a, b, c) { if (!a || !b || !c) return 0; const rad = Math.atan2(c.y - b.y, c.x - b.x) - Math.atan2(a.y - b.y, a.x - b.x); let angle = Math.abs(rad * 180.0 / Math.PI); return angle > 180.0 ? 360 - angle : angle; }
        function getDistance(p1, p2) { if (!p1 || !p2) return Infinity; return Math.hypot(p1.x - p2.x, p1.y - p2.y); }
        function getNormalizedScore(current, good, bad, isAngle = false) { if (isAngle) { if (current >= good) return 1.0; if (current <= bad) return 0.0; return (current - bad) / (good - bad); } else { if (current <= good) return 1.0; if (current >= bad) return 0.0; return 1.0 - ((current - good) / (bad - good)); } }
        
        // [IMPROVED] 팔꿈치 위치 판별 함수 (좌우 분리)
        function isElbowOutside(elbow, shoulder, hip, side) {
            if (!elbow || !shoulder || !hip) return false;
            if (side === 'left') { // 왼쪽 팔: 팔꿈치가 어깨/골반보다 x좌표가 커야 함
                return elbow.x > shoulder.x && elbow.x > hip.x;
            } else { // 오른쪽 팔: 팔꿈치가 어깨/골반보다 x좌표가 작아야 함
                return elbow.x < shoulder.x && elbow.x < hip.x;
            }
        }
        
        // 주먹 인식 함수
        function isFist(handLandmarks) {
            if(!handLandmarks) return false;
            const fingerTips = [handLandmarks[8], handLandmarks[12], handLandmarks[16], handLandmarks[20]];
            const palmCenter = { x: (handLandmarks[5].x + handLandmarks[17].x) / 2, y: (handLandmarks[5].y + handLandmarks[17].y) / 2 };
            const baseDist = getDistance(handLandmarks[4], handLandmarks[5]);
            for (const tip of fingerTips) { if (getDistance(tip, palmCenter) > baseDist) return false; }
            return true;
        }

        // 슛 동작 인식 함수
        function isShootPose(handLandmarks) {
            if(!handLandmarks) return false;
            const wrist = handLandmarks[0], indexTip = handLandmarks[8], middleTip = handLandmarks[12], ringTip = handLandmarks[16], pinkyTip = handLandmarks[20], indexPip = handLandmarks[6];
            const baseDist = getDistance(wrist, indexPip);
            return getDistance(wrist, indexTip) > baseDist * 2.5 && getDistance(wrist, middleTip) > baseDist * 2.5 && getDistance(wrist, ringTip) < baseDist * 2.2 && getDistance(wrist, pinkyTip) < baseDist * 2.0;
        }

        // 그리기 함수
        function drawLine(ctx, p1, p2, color, width) { if (!p1 || !p2 || p1.visibility < 0.5 || p2.visibility < 0.5) return; ctx.beginPath(); ctx.moveTo(p1.x, p1.y); ctx.lineTo(p2.x, p2.y); ctx.strokeStyle = color; ctx.lineWidth = width; ctx.stroke(); }
        function drawStickFigure(ctx, p, color) { /* ... 기존과 동일 (축약) ... */ if (!p) return; const lineWidth = 6; const shoulderMid = p[11] && p[12] ? { x: (p[11].x + p[12].x) / 2, y: (p[11].y + p[12].y) / 2, visibility: (p[11].visibility + p[12].visibility) / 2 } : null; const hipMid = p[23] && p[24] ? { x: (p[23].x + p[24].x) / 2, y: (p[23].y + p[24].y) / 2, visibility: (p[23].visibility + p[24].visibility) / 2 } : null; drawLine(ctx, shoulderMid, hipMid, color, lineWidth); if (p[0]) drawLine(ctx, shoulderMid, p[0], color, lineWidth); drawLine(ctx, p[11], p[12], color, lineWidth); drawLine(ctx, p[23], p[24], color, lineWidth); drawLine(ctx, p[11], p[13], color, lineWidth); drawLine(ctx, p[13], p[15], color, lineWidth); drawLine(ctx, p[12], p[14], color, lineWidth); drawLine(ctx, p[14], p[16], color, lineWidth); drawLine(ctx, p[23], p[25], color, lineWidth); drawLine(ctx, p[25], p[27], color, lineWidth); drawLine(ctx, p[24], p[26], color, lineWidth); drawLine(ctx, p[26], p[28], color, lineWidth); }
        function drawHands(ctx, handLandmarks, color) { if (!handLandmarks) return; drawingUtils.drawConnectors(ctx, handLandmarks, window.HAND_CONNECTIONS, {color: color, lineWidth: 4}); drawingUtils.drawLandmarks(ctx, handLandmarks, {color: color, lineWidth: -1, radius: 4}); }

        // [FIX] 모델 결과 콜백: 데이터 저장만 수행
        function onPoseResults(results) { lastPoseResults = results; }
        function onHandResults(results) { lastHandResults = results; }

        // [RESTRUCTURED] 모든 로직을 처리하는 메인 함수
        function processAndDraw() {
            // 두 모델의 결과가 모두 준비되었는지 확인
            if (!lastPoseResults || !lastPoseResults.poseLandmarks || !lastHandResults) {
                canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
                messageDiv.innerText = "DETECTING...";
                return; // 데이터가 없으면 아무것도 하지 않음
            }

            const width = videoElement.videoWidth, height = videoElement.videoHeight;
            canvasCtx.save();
            canvasCtx.clearRect(0, 0, width, height);

            // Pose 랜드마크를 화면 좌표로 변환
            const p = {};
            lastPoseResults.poseLandmarks.forEach((lm, idx) => p[idx] = toPixel(lm, width, height));

            // T-자세 정확도 및 그라데이션 계산
            const BODY_TILT_LIMIT = 5, ARM_HORIZON_LIMIT = 15, ELBOW_STRAIGHT_MIN = 165;
            const BODY_TILT_BAD = 20, ARM_HORIZON_BAD = 45, ELBOW_STRAIGHT_BAD = 130;
            const lElbow = calculateAngle(p[11], p[13], p[15]);
            const rElbow = calculateAngle(p[12], p[14], p[16]);
            const lArmS = getNormalizedScore(lElbow, ELBOW_STRAIGHT_MIN, ELBOW_STRAIGHT_BAD, true);
            const rArmS = getNormalizedScore(rElbow, ELBOW_STRAIGHT_MIN, ELBOW_STRAIGHT_BAD, true);
            const progressScore = Math.max(lArmS, rArmS);
            const isSuccess = (lElbow > ELBOW_STRAIGHT_MIN) || (rElbow > ELBOW_STRAIGHT_MIN);

            // 손 모양 인식
            let leftHand, rightHand;
            if (lastHandResults.multiHandLandmarks) {
                for (let i = 0; i < lastHandResults.multiHandLandmarks.length; i++) {
                    const handedness = lastHandResults.multiHandedness[i].label;
                    if (handedness === 'Left') leftHand = lastHandResults.multiHandLandmarks[i];
                    else if (handedness === 'Right') rightHand = lastHandResults.multiHandLandmarks[i];
                }
            }
            const isLeftFist = isFist(leftHand);
            const isRightFist = isFist(rightHand);
            const isLeftShoot = isShootPose(leftHand);
            const isRightShoot = isShootPose(rightHand);
            
            // Pulling 소리 로직
            if (isLeftFist && lElbow < ELBOW_BENT_ANGLE && isElbowOutside(p[13], p[11], p[23], 'left') && lastFrameState.prevLeftElbowPos) {
                if (getDistance(p[13], lastFrameState.prevLeftElbowPos) > ELBOW_MOVE_THRESHOLD) {
                    if (pullingAudio && pullingAudio.paused) pullingAudio.play().catch(e => {});
                }
            }
            if (isRightFist && rElbow < ELBOW_BENT_ANGLE && isElbowOutside(p[14], p[12], p[24], 'right') && lastFrameState.prevRightElbowPos) {
                if (getDistance(p[14], lastFrameState.prevRightElbowPos) > ELBOW_MOVE_THRESHOLD) {
                    if (pullingAudio && pullingAudio.paused) pullingAudio.play().catch(e => {});
                }
            }

            // Shoot 소리 로직
            const faceProximity = getDistance(p[11], p[12]);
            if (lastFrameState.wasLeftFist && isLeftShoot && getDistance(p[15], p[0]) < faceProximity) {
                if (shootAudio) { shootAudio.currentTime = 0; shootAudio.play().catch(e => {}); }
            }
            if (lastFrameState.wasRightFist && isRightShoot && getDistance(p[16], p[0]) < faceProximity) {
                if (shootAudio) { shootAudio.currentTime = 0; shootAudio.play().catch(e => {}); }
            }

            // 그리기 및 UI 업데이트
            let color;
            if (isSuccess) {
                color = "#00FF00"; messageDiv.innerText = "SUCCESS";
                if (!lastFrameState.isSuccess && successAudio) {
                    successAudio.currentTime = 0; successAudio.play().catch(e => {});
                }
            } else {
                const white = Math.floor(255 * progressScore); color = `rgb(255, ${white}, ${white})`;
                messageDiv.innerText = "STAND STRAIGHT";
            }
            messageDiv.style.borderColor = color; messageDiv.style.color = isSuccess ? color : "#FFFFFF";
            debugDiv.innerText = `POSE ACCURACY: ${(progressScore * 100).toFixed(0)}%`;
            
            drawStickFigure(canvasCtx, p, color);
            drawHands(canvasCtx, leftHand, color);
            drawHands(canvasCtx, rightHand, color);

            // 상태 업데이트
            lastFrameState.isSuccess = isSuccess;
            lastFrameState.prevLeftElbowPos = p[13]; lastFrameState.prevRightElbowPos = p[14];
            lastFrameState.wasLeftFist = isLeftFist; lastFrameState.wasRightFist = isRightFist;

            canvasCtx.restore();
        }

        // 메인 애니메이션 루프
        async function renderFrame() {
            if (isRunning && !videoElement.paused && !videoElement.ended) {
                // 두 모델에 동시에 이미지 전송 요청
                await Promise.all([
                    pose.send({ image: videoElement }),
                    hands.send({ image: videoElement })
                ]);
                processAndDraw(); // 데이터 처리 및 그리기
            }
            requestAnimationFrame(renderFrame);
        }

        // 초기 설정
        async function setup() {
            messageDiv.innerText = "LOADING MODELS...";
            pose = new Pose({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/pose/${file}`});
            pose.setOptions({ modelComplexity: 1, smoothLandmarks: true, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
            pose.onResults(onPoseResults);

            hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
            hands.setOptions({ maxNumHands: 2, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
            hands.onResults(onHandResults);

            const stream = await navigator.mediaDevices.getUserMedia({ video: { width: { ideal: 1280 }, height: { ideal: 720 }, facingMode: isFrontCamera ? 'user' : 'environment' }, audio: false });
            videoElement.srcObject = stream;
            videoElement.className = isFrontCamera ? 'mirror' : 'normal';
            canvasElement.className = isFrontCamera ? 'mirror' : 'normal';
            
            return new Promise((resolve) => {
                videoElement.onloadedmetadata = () => { videoElement.play(); resolve(); };
            });
        }

        startOverlay.addEventListener('click', async () => {
            if (!successAudio) { successAudio = new Audio('success.mp3'); successAudio.load(); }
            if (!pullingAudio) { pullingAudio = new Audio('pulling.mp3'); pullingAudio.load(); }
            if (!shootAudio) { shootAudio = new Audio('shoot.mp3'); shootAudio.load(); }
            
            startOverlay.style.display = 'none';
            await setup();
            isRunning = true;
            renderFrame();
        });
        
        switchBtn.addEventListener('click', async () => { 
            isRunning = false;
            isFrontCamera = !isFrontCamera; 
            switchBtn.innerText = "LOADING..."; 
            await setup();
            isRunning = true;
            switchBtn.innerText = "CAM SWITCH";
        });
    </script>
</body>
</html>
