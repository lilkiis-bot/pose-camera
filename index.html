<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Stickman Pose Audio</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #000;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: 'Courier New', Courier, monospace; /* 각진 폰트 */
        }
        .container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        video, canvas {
            position: absolute;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        .mirror { transform: scaleX(-1); }
        .normal { transform: scaleX(1); }
        
        video { z-index: 1; }
        canvas { z-index: 2; }

        /* UI 스타일: 둥근 느낌 제거, 테두리 각지게 */
        #status-box {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 3;
            width: 90%;
            text-align: center;
            pointer-events: none;
        }
        #message {
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 15px;
            border: 2px solid #FF0000; /* 각진 테두리 */
            font-size: 1rem;
            font-weight: bold;
            text-transform: uppercase;
            transition: all 0.2s; /* 색상 변경 시 부드러운 전환 효과 */
        }
        #debug {
            margin-top: 5px;
            font-size: 0.8rem;
            color: #ccc;
            background: black;
            display: inline-block;
            padding: 2px 5px;
        }

        /* 버튼 스타일: 텍스트만 사용, 각지게 */
        #switch-btn {
            position: absolute;
            bottom: 30px;
            right: 20px;
            z-index: 4;
            background-color: #333;
            color: white;
            border: 2px solid white;
            padding: 15px 20px;
            font-family: inherit;
            font-weight: bold;
            font-size: 1rem;
            cursor: pointer;
        }
        #switch-btn:active {
            background-color: white;
            color: black;
        }

        /* 시작 오버레이 (소리 권한용) */
        #start-overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9);
            z-index: 10;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            cursor: pointer;
        }
        #start-btn {
            border: 2px solid #00FF00;
            padding: 20px;
            margin-top: 20px;
            font-size: 1.5rem;
            color: #00FF00;
        }
    </style>
    <!-- MediaPipe -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose/pose.js" crossorigin="anonymous"></script>
</head>
<body>
    <div class="container">
        <video id="input_video" class="mirror" playsinline autoplay muted></video>
        <canvas id="output_canvas" class="mirror"></canvas>
        
        <div id="status-box">
            <div id="message">WAITING FOR CAMERA...</div>
            <div id="debug"></div>
        </div>

        <button id="switch-btn">CAM SWITCH</button>

        <!-- 소리 재생 권한을 얻기 위한 시작 화면 -->
        <div id="start-overlay">
            <div>TOUCH TO START</div>
            <div id="start-btn">START</div>
        </div>
    </div>

    <script>
        const videoElement = document.getElementById('input_video');
        const canvasElement = document.getElementById('output_canvas');
        const canvasCtx = canvasElement.getContext('2d');
        const messageDiv = document.getElementById('message');
        const debugDiv = document.getElementById('debug');
        const switchBtn = document.getElementById('switch-btn');
        const startOverlay = document.getElementById('start-overlay');

        // === [소리 설정] ===
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        let wasSuccessLastFrame = false; // 이전 프레임의 성공 여부 추적

        let isFrontCamera = true;
        let currentStream = null;
        let pose = null;
        let isRunning = false;

        // 좌표 변환
        function toPixel(landmark, width, height) {
            return { x: landmark.x * width, y: landmark.y * height };
        }

        // 각도 및 편차 계산 함수들
        function calculateAngle(a, b, c) {
            const radians = Math.atan2(c.y - b.y, c.x - b.x) - Math.atan2(a.y - b.y, a.x - b.x);
            let angle = Math.abs(radians * 180.0 / Math.PI);
            if (angle > 180.0) angle = 360 - angle;
            return angle;
        }

        function calculateVerticalDeviation(a, b) {
            const dx = Math.abs(b.x - a.x);
            const dy = Math.abs(b.y - a.y);
            const radians = Math.atan2(dx, dy); 
            return radians * 180.0 / Math.PI;
        }

        function calculateHorizontalDeviation(a, b) {
            const dy = b.y - a.y;
            const dx = b.x - a.x;
            let angle = Math.atan2(dy, dx) * 180.0 / Math.PI;
            angle = Math.abs(angle); 
            if (angle > 90) angle = Math.abs(180 - angle);
            return angle;
        }
        
        // [NEW] 값의 진행률을 0~1로 정규화하는 함수
        // current: 현재 값, good: 좋은 값(목표), bad: 나쁜 값(이것보다 나쁘면 0점)
        function getNormalizedScore(current, good, bad, isAngle = false) {
            if (isAngle) { // 각도가 클수록 좋은 경우 (e.g., 팔꿈치, 무릎)
                if (current >= good) return 1.0;
                if (current <= bad) return 0.0;
                return (current - bad) / (good - bad);
            } else { // 값이 작을수록 좋은 경우 (e.g., 기울기)
                if (current <= good) return 1.0;
                if (current >= bad) return 0.0;
                return 1.0 - ((current - good) / (bad - good));
            }
        }


        // === [커스텀 그리기 함수: 스틱맨] ===
        function drawLine(ctx, p1, p2, color, width) {
            if (!p1 || !p2) return;
            ctx.beginPath();
            ctx.moveTo(p1.x, p1.y);
            ctx.lineTo(p2.x, p2.y);
            ctx.strokeStyle = color;
            ctx.lineWidth = width;
            ctx.stroke();
        }

        function drawStickFigure(ctx, p, color) {
            const lineWidth = 6; // 선 두께

            if (p[0] && p[11] && p[12]) {
                const shoulderMidX = (p[11].x + p[12].x) / 2;
                const shoulderMidY = (p[11].y + p[12].y) / 2;
                drawLine(ctx, {x: shoulderMidX, y: shoulderMidY}, p[0], color, lineWidth);
            }
            drawLine(ctx, p[11], p[12], color, lineWidth); 
            drawLine(ctx, p[11], p[23], color, lineWidth); 
            drawLine(ctx, p[12], p[24], color, lineWidth); 
            drawLine(ctx, p[23], p[24], color, lineWidth); 
            drawLine(ctx, p[11], p[13], color, lineWidth);
            drawLine(ctx, p[13], p[15], color, lineWidth);
            drawLine(ctx, p[12], p[14], color, lineWidth);
            drawLine(ctx, p[14], p[16], color, lineWidth);
            drawLine(ctx, p[23], p[25], color, lineWidth);
            drawLine(ctx, p[25], p[27], color, lineWidth);
            drawLine(ctx, p[24], p[26], color, lineWidth);
            drawLine(ctx, p[26], p[28], color, lineWidth);
        }

        function onResults(results) {
            if (!isRunning) return;

            const width = videoElement.videoWidth;
            const height = videoElement.videoHeight;
            canvasElement.width = width;
            canvasElement.height = height;

            canvasCtx.save();
            canvasCtx.clearRect(0, 0, width, height);

            if (results.poseLandmarks) {
                const rawLm = results.poseLandmarks;
                const p = {};
                [0, 11,12,13,14,15,16,23,24,25,26,27,28].forEach(idx => {
                    if(rawLm[idx]) p[idx] = toPixel(rawLm[idx], width, height);
                });

                // === [엄격한 기준] ===
                const BODY_TILT_LIMIT = 5;      
                const ARM_HORIZON_LIMIT = 15;   
                const ELBOW_STRAIGHT_MIN = 165; 
                const KNEE_STRAIGHT_MIN = 170;  

                // [NEW] 색상 그라데이션을 위한 '나쁜' 기준
                const BODY_TILT_BAD = 20;
                const ARM_HORIZON_BAD = 45;
                const ELBOW_STRAIGHT_BAD = 130;
                const KNEE_STRAIGHT_BAD = 140;

                let isBodyReady = false;
                let isArmReady = false;
                let failReason = "";
                let progressScore = 0;

                if(p[11] && p[23] && p[27] && p[12] && p[24] && p[28]) {
                    const lTorso = calculateVerticalDeviation(p[11], p[23]);
                    const lLeg = calculateVerticalDeviation(p[23], p[27]);
                    const lKnee = calculateAngle(p[23], p[25], p[27]);
                    
                    const rTorso = calculateVerticalDeviation(p[12], p[24]);
                    const rLeg = calculateVerticalDeviation(p[24], p[28]);
                    const rKnee = calculateAngle(p[24], p[26], p[28]);

                    const leftBodyOk = (lTorso < BODY_TILT_LIMIT) && (lLeg < BODY_TILT_LIMIT) && (lKnee > KNEE_STRAIGHT_MIN);
                    const rightBodyOk = (rTorso < BODY_TILT_LIMIT) && (rLeg < BODY_TILT_LIMIT) && (rKnee > KNEE_STRAIGHT_MIN);

                    isBodyReady = leftBodyOk || rightBodyOk;

                    const lElbow = calculateAngle(p[11], p[13], p[15]);
                    const rElbow = calculateAngle(p[12], p[14], p[16]);
                    const lHorizon = calculateHorizontalDeviation(p[11], p[15]);
                    const rHorizon = calculateHorizontalDeviation(p[12], p[16]);

                    const leftArmOk = (lElbow > ELBOW_STRAIGHT_MIN) && (lHorizon < ARM_HORIZON_LIMIT);
                    const rightArmOk = (rElbow > ELBOW_STRAIGHT_MIN) && (rHorizon < ARM_HORIZON_LIMIT);

                    isArmReady = leftArmOk || rightArmOk;
                    
                    // [NEW] 진행도 계산
                    const lBodyScore = Math.min(
                        getNormalizedScore(lTorso, BODY_TILT_LIMIT, BODY_TILT_BAD),
                        getNormalizedScore(lLeg, BODY_TILT_LIMIT, BODY_TILT_BAD),
                        getNormalizedScore(lKnee, KNEE_STRAIGHT_MIN, KNEE_STRAIGHT_BAD, true)
                    );
                    const lArmScore = Math.min(
                        getNormalizedScore(lHorizon, ARM_HORIZON_LIMIT, ARM_HORIZON_BAD),
                        getNormalizedScore(lElbow, ELBOW_STRAIGHT_MIN, ELBOW_STRAIGHT_BAD, true)
                    );
                    const rBodyScore = Math.min(
                        getNormalizedScore(rTorso, BODY_TILT_LIMIT, BODY_TILT_BAD),
                        getNormalizedScore(rLeg, BODY_TILT_LIMIT, BODY_TILT_BAD),
                        getNormalizedScore(rKnee, KNEE_STRAIGHT_MIN, KNEE_STRAIGHT_BAD, true)
                    );
                    const rArmScore = Math.min(
                        getNormalizedScore(rHorizon, ARM_HORIZON_LIMIT, ARM_HORIZON_BAD),
                        getNormalizedScore(rElbow, ELBOW_STRAIGHT_MIN, ELBOW_STRAIGHT_BAD, true)
                    );
                    
                    // 양쪽 중 더 잘된 쪽의 점수를 최종 점수로 사용
                    const leftScore = Math.min(lBodyScore, lArmScore);
                    const rightScore = Math.min(rBodyScore, rArmScore);
                    progressScore = Math.max(leftScore, rightScore);

                    if (!isBodyReady) failReason = "BODY TILT DETECTED";
                    else if (!isArmReady) failReason = "ARM NOT HORIZONTAL";
                }

                const isSuccess = isBodyReady && isArmReady;
                let color;

                if (isSuccess) {
                    color = "#00FF00"; // GREEN
                    messageDiv.innerText = "SUCCESS";
                    messageDiv.style.borderColor = "#00FF00";
                    messageDiv.style.color = "#00FF00";
                    debugDiv.innerText = `POSE ACCURACY: ${(progressScore * 100).toFixed(0)}%`;
                    
                    // [NEW] 소리 재생 로직: 성공 상태로 '진입'했을 때 한번만 재생
                    if (!wasSuccessLastFrame) {
                        new Audio('success.mp3').play().catch(e => console.error("Audio play failed:", e));
                    }

                } else {
                    // [NEW] 진행도에 따라 빨간색 -> 흰색으로 색상 변경
                    const whiteComponent = Math.floor(255 * progressScore);
                    color = `rgb(255, ${whiteComponent}, ${whiteComponent})`;
                    
                    messageDiv.innerText = failReason || "STAND STRAIGHT";
                    messageDiv.style.borderColor = color; // 테두리 색도 같이 변경
                    messageDiv.style.color = "#FFFFFF";
                    debugDiv.innerText = `POSE ACCURACY: ${(progressScore * 100).toFixed(0)}%`;
                }
                
                // 이전 프레임 상태 업데이트
                wasSuccessLastFrame = isSuccess;

                // 스틱맨 그리기 호출
                drawStickFigure(canvasCtx, p, color);
            } else {
                 messageDiv.innerText = "NO PERSON DETECTED";
                 messageDiv.style.borderColor = "#FF0000";
                 messageDiv.style.color = "#FFFFFF";
                 debugDiv.innerText = "";
            }
            canvasCtx.restore();
        }

        async function setupCamera() {
            if (currentStream) currentStream.getTracks().forEach(track => track.stop());
            const constraints = {
                video: { width: { ideal: 1280 }, height: { ideal: 720 }, facingMode: isFrontCamera ? 'user' : 'environment' },
                audio: false
            };
            try {
                const stream = await navigator.mediaDevices.getUserMedia(constraints);
                currentStream = stream;
                videoElement.srcObject = stream;
                if (isFrontCamera) { videoElement.className = 'mirror'; canvasElement.className = 'mirror'; } 
                else { videoElement.className = 'normal'; canvasElement.className = 'normal'; }
                return new Promise((resolve) => { videoElement.onloadedmetadata = () => { resolve(videoElement); }; });
            } catch (err) { alert("Camera Error: " + err.message); }
        }

        async function renderFrame() {
            if (!videoElement.paused && !videoElement.ended) { await pose.send({image: videoElement}); }
            requestAnimationFrame(renderFrame);
        }

        async function initPose() {
            messageDiv.innerText = "LOADING MODEL...";
            pose = new Pose({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/pose/${file}`});
            pose.setOptions({ modelComplexity: 1, smoothLandmarks: true, enableSegmentation: false, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
            pose.onResults(onResults);
            await setupCamera();
            videoElement.play();
            renderFrame();
            messageDiv.innerText = "READY";
        }

        startOverlay.addEventListener('click', () => {
            if (audioContext.state === 'suspended') {
                audioContext.resume();
            }
            startOverlay.style.display = 'none';
            isRunning = true;
            
            // 더미 사운드를 재생하여 오디오 컨텍스트를 활성화
            const dummySound = new Audio();
            dummySound.play().catch(() => {});
            
            initPose();
        });

        switchBtn.addEventListener('click', async () => {
            isFrontCamera = !isFrontCamera;
            switchBtn.innerText = "LOADING...";
            await setupCamera();
            videoElement.play();
            switchBtn.innerText = "CAM SWITCH";
        });

    </script>
</body>
</html>
