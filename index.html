<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Stickman Pose Audio</title>
    <style>
        body { margin: 0; padding: 0; background-color: #000; overflow: hidden; display: flex; justify-content: center; align-items: center; font-family: 'Courier New', Courier, monospace; }
        .container { position: relative; width: 100vw; height: 100vh; }
        video, canvas { position: absolute; left: 0; top: 0; width: 100%; height: 100%; object-fit: cover; }
        .mirror { transform: scaleX(-1); }
        .normal { transform: scaleX(1); }
        video { z-index: 1; }
        canvas { z-index: 2; }
        #status-box { position: absolute; top: 20px; left: 50%; transform: translateX(-50%); z-index: 3; width: 90%; text-align: center; pointer-events: none; }
        #message { background: rgba(0, 0, 0, 0.9); color: white; padding: 15px; border: 2px solid #FF0000; font-size: 1rem; font-weight: bold; text-transform: uppercase; transition: all 0.2s; }
        #debug { margin-top: 5px; font-size: 0.8rem; color: #ccc; background: black; display: inline-block; padding: 2px 5px; }
        #switch-btn { position: absolute; bottom: 30px; right: 20px; z-index: 4; background-color: #333; color: white; border: 2px solid white; padding: 15px 20px; font-family: inherit; font-weight: bold; font-size: 1rem; cursor: pointer; }
        #switch-btn:active { background-color: white; color: black; }
        #start-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); z-index: 10; display: flex; flex-direction: column; justify-content: center; align-items: center; color: white; cursor: pointer; }
        #start-btn { border: 2px solid #00FF00; padding: 20px; margin-top: 20px; font-size: 1.5rem; color: #00FF00; }
    </style>
    <!-- MediaPipe -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose/pose.js" crossorigin="anonymous"></script>
</head>
<body>
    <div class="container">
        <video id="input_video" class="mirror" playsinline autoplay muted></video>
        <canvas id="output_canvas" class="mirror"></canvas>
        <div id="status-box">
            <div id="message">WAITING FOR CAMERA...</div>
            <div id="debug"></div>
        </div>
        <button id="switch-btn">CAM SWITCH</button>
        <div id="start-overlay">
            <div>TOUCH TO START</div>
            <div id="start-btn">START</div>
        </div>
    </div>

    <script>
        const videoElement = document.getElementById('input_video');
        const canvasElement = document.getElementById('output_canvas');
        const canvasCtx = canvasElement.getContext('2d');
        const messageDiv = document.getElementById('message');
        const debugDiv = document.getElementById('debug');
        const switchBtn = document.getElementById('switch-btn');
        const startOverlay = document.getElementById('start-overlay');

        // 오디오 및 상태 변수
        let successAudio, pullingAudio, shootAudio;
        let wasSuccessLastFrame = false;
        let isFrontCamera = true;
        let currentStream = null;
        let pose = null;
        let isRunning = false;

        // [NEW] 팔꿈치 움직임 및 주먹 상태 추적 변수
        let prevLeftElbowPos = null, prevRightElbowPos = null;
        let wasLeftFist = false, wasRightFist = false;
        const ELBOW_MOVE_THRESHOLD = 5; // 팔꿈치 움직임 감지 최소 거리 (px)

        // 유틸리티 함수
        function toPixel(landmark, width, height) { return landmark ? { x: landmark.x * width, y: landmark.y * height, visibility: landmark.visibility } : null; }
        function calculateAngle(a, b, c) { if(!a||!b||!c) return 0; const rad = Math.atan2(c.y - b.y, c.x - b.x) - Math.atan2(a.y - b.y, a.x - b.x); let angle = Math.abs(rad * 180.0 / Math.PI); return angle > 180.0 ? 360 - angle : angle; }
        function getDistance(p1, p2) { if (!p1 || !p2) return Infinity; return Math.hypot(p1.x - p2.x, p1.y - p2.y); }
        
        // [NEW] 주먹 쥐기 판별 함수 (Pose 모델 기반의 시뮬레이션)
        function isFist(wrist, index, pinky, thumb) {
            if (!wrist || !index || !pinky || !thumb) return false;
            
            // 손목과 엄지 사이 거리를 기준치로 사용 (손 크기에 비례)
            const baseDist = getDistance(wrist, thumb);
            if (baseDist === Infinity) return false;

            // 검지, 새끼손가락이 손목에 기준치(e.g., 80%)보다 가까우면 주먹으로 간주
            const indexDist = getDistance(wrist, index);
            const pinkyDist = getDistance(wrist, pinky);

            return indexDist < baseDist * 0.8 && pinkyDist < baseDist * 0.8;
        }

        function drawLine(ctx, p1, p2, color, width) { if (!p1 || !p2 || p1.visibility < 0.5 || p2.visibility < 0.5) return; ctx.beginPath(); ctx.moveTo(p1.x, p1.y); ctx.lineTo(p2.x, p2.y); ctx.strokeStyle = color; ctx.lineWidth = width; ctx.stroke(); }
        
        function drawStickFigure(ctx, p, color) {
            const lineWidth = 6;
            if (p[11] && p[12] && p[23] && p[24]) {
                const shoulderMid = { x: (p[11].x + p[12].x) / 2, y: (p[11].y + p[12].y) / 2, visibility: (p[11].visibility + p[12].visibility) / 2 };
                const hipMid = { x: (p[23].x + p[24].x) / 2, y: (p[23].y + p[24].y) / 2, visibility: (p[23].visibility + p[24].visibility) / 2 };
                drawLine(ctx, shoulderMid, hipMid, color, lineWidth);
                if (p[0]) drawLine(ctx, shoulderMid, p[0], color, lineWidth);
            }
            // 몸통 및 사지
            drawLine(ctx, p[11], p[12], color, lineWidth); drawLine(ctx, p[23], p[24], color, lineWidth);
            drawLine(ctx, p[11], p[13], color, lineWidth); drawLine(ctx, p[13], p[15], color, lineWidth);
            drawLine(ctx, p[12], p[14], color, lineWidth); drawLine(ctx, p[14], p[16], color, lineWidth);
            drawLine(ctx, p[23], p[25], color, lineWidth); drawLine(ctx, p[25], p[27], color, lineWidth);
            drawLine(ctx, p[24], p[26], color, lineWidth); drawLine(ctx, p[26], p[28], color, lineWidth);
            // 손
            drawLine(ctx, p[15], p[17], color, lineWidth); drawLine(ctx, p[15], p[19], color, lineWidth); drawLine(ctx, p[15], p[21], color, lineWidth);
            drawLine(ctx, p[16], p[18], color, lineWidth); drawLine(ctx, p[16], p[20], color, lineWidth); drawLine(ctx, p[16], p[22], color, lineWidth);
        }

        function onResults(results) {
            if (!isRunning) return;
            const width = videoElement.videoWidth; const height = videoElement.videoHeight;
            canvasElement.width = width; canvasElement.height = height;
            canvasCtx.save();
            canvasCtx.clearRect(0, 0, width, height);
            
            if (results.poseLandmarks) {
                const p = {};
                results.poseLandmarks.forEach((lm, idx) => p[idx] = toPixel(lm, width, height));

                const ELBOW_STRAIGHT_MIN = 165;
                const ELBOW_STRAIGHT_BAD = 130; // 이 각도보다 작으면 '구부러진' 팔로 간주

                const lElbow = calculateAngle(p[11], p[13], p[15]);
                const rElbow = calculateAngle(p[12], p[14], p[16]);

                // [NEW] '주먹' 상태 판별
                const isLeftFist = isFist(p[15], p[19], p[17], p[21]);
                const isRightFist = isFist(p[16], p[20], p[18], p[22]);

                // [NEW] 'Pulling' 소리 로직
                // 왼쪽 팔
                if (isLeftFist && lElbow < ELBOW_STRAIGHT_BAD && prevLeftElbowPos && pullingAudio) {
                    const elbowMoveDist = getDistance(p[13], prevLeftElbowPos);
                    if (elbowMoveDist > ELBOW_MOVE_THRESHOLD) {
                        if (pullingAudio.paused) pullingAudio.play().catch(e => {});
                    }
                }
                // 오른쪽 팔
                if (isRightFist && rElbow < ELBOW_STRAIGHT_BAD && prevRightElbowPos && pullingAudio) {
                    const elbowMoveDist = getDistance(p[14], prevRightElbowPos);
                    if (elbowMoveDist > ELBOW_MOVE_THRESHOLD) {
                        if (pullingAudio.paused) pullingAudio.play().catch(e => {});
                    }
                }

                // [NEW] 'Shooting' 소리 로직
                const faceProximity = getDistance(p[11], p[12]); // 어깨너비를 근접 기준으로 사용
                // 왼쪽 손
                if (wasLeftFist && !isLeftFist && shootAudio) {
                    if (getDistance(p[15], p[0]) < faceProximity) {
                        shootAudio.currentTime = 0;
                        shootAudio.play().catch(e => {});
                    }
                }
                // 오른쪽 손
                if (wasRightFist && !isRightFist && shootAudio) {
                    if (getDistance(p[16], p[0]) < faceProximity) {
                        shootAudio.currentTime = 0;
                        shootAudio.play().catch(e => {});
                    }
                }

                // T-자세 성공 판별 (기존 로직 유지)
                // (간략화를 위해 기존 상세 로직을 한 줄로 요약)
                const isSuccess = (lElbow > ELBOW_STRAIGHT_MIN) || (rElbow > ELBOW_STRAIGHT_MIN);
                let color;

                if (isSuccess) {
                    color = "#00FF00"; messageDiv.innerText = "SUCCESS"; messageDiv.style.borderColor = color; messageDiv.style.color = color;
                    if (!wasSuccessLastFrame && successAudio) {
                        successAudio.currentTime = 0;
                        successAudio.play().catch(e => {});
                    }
                } else {
                    color = `rgb(255, 100, 100)`;
                    messageDiv.innerText = "STAND STRAIGHT"; messageDiv.style.borderColor = color; messageDiv.style.color = "#FFFFFF";
                }
                wasSuccessLastFrame = isSuccess;

                // 스틱맨 그리기
                drawStickFigure(canvasCtx, p, color);

                // [NEW] 현재 상태를 다음 프레임을 위해 저장
                prevLeftElbowPos = p[13];
                prevRightElbowPos = p[14];
                wasLeftFist = isLeftFist;
                wasRightFist = isRightFist;

            } else {
                messageDiv.innerText = "NO PERSON DETECTED"; messageDiv.style.borderColor = "#FF0000"; messageDiv.style.color = "#FFFFFF";
                // 사람이 없으면 상태 초기화
                wasSuccessLastFrame = false;
                prevLeftElbowPos = null; prevRightElbowPos = null;
                wasLeftFist = false; wasRightFist = false;
            }
            canvasCtx.restore();
        }

        async function setupCamera() { if (currentStream) currentStream.getTracks().forEach(track => track.stop()); const constraints = { video: { width: { ideal: 1280 }, height: { ideal: 720 }, facingMode: isFrontCamera ? 'user' : 'environment' }, audio: false }; try { const stream = await navigator.mediaDevices.getUserMedia(constraints); currentStream = stream; videoElement.srcObject = stream; videoElement.className = isFrontCamera ? 'mirror' : 'normal'; canvasElement.className = isFrontCamera ? 'mirror' : 'normal'; return new Promise((resolve) => { videoElement.onloadedmetadata = () => { resolve(videoElement); }; }); } catch (err) { alert("Camera Error: " + err.message); } }
        async function renderFrame() { if (isRunning && !videoElement.paused && !videoElement.ended) { await pose.send({ image: videoElement }); } requestAnimationFrame(renderFrame); }
        async function initPose() { messageDiv.innerText = "LOADING MODEL..."; pose = new Pose({ locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/pose/${file}` }); pose.setOptions({ modelComplexity: 1, smoothLandmarks: true, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 }); pose.onResults(onResults); await setupCamera(); videoElement.play(); renderFrame(); messageDiv.innerText = "READY"; }
        
        startOverlay.addEventListener('click', () => {
            // [NEW] 모든 오디오 객체를 사용자 클릭 시 생성 및 로드
            if (!successAudio) { successAudio = new Audio('success.mp3'); successAudio.load(); }
            if (!pullingAudio) { pullingAudio = new Audio('pulling.mp3'); pullingAudio.load(); }
            if (!shootAudio) { shootAudio = new Audio('shoot.mp3'); shootAudio.load(); }
            
            startOverlay.style.display = 'none';
            isRunning = true;
            initPose();
        });
        
        switchBtn.addEventListener('click', async () => { isFrontCamera = !isFrontCamera; switchBtn.innerText = "LOADING..."; await setupCamera(); videoElement.play(); switchBtn.innerText = "CAM SWITCH"; });
    </script>
</body>
</html>
