<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Shoulder-Elbow Shortening Sound</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #000;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: 'Courier New', Courier, monospace;
        }
        .container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        video, canvas {
            position: absolute;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        .mirror { transform: scaleX(-1); }
        .normal { transform: scaleX(1); }
        
        video { z-index: 1; }
        canvas { z-index: 2; }

        /* UI Ïä§ÌÉÄÏùº */
        #status-box {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 3;
            width: 90%;
            text-align: center;
            pointer-events: none;
        }
        #message {
            background: rgba(128, 128, 128, 0.5);
            color: white;
            padding: 15px;
            border: 2px solid rgba(255, 255, 255, 0.7);
            font-size: 1.2rem;
            font-weight: bold;
            text-transform: uppercase;
        }
        #debug {
            margin-top: 5px;
            font-size: 0.9rem;
            color: #FFFFFF;
            background: rgba(128, 128, 128, 0.5);
            display: inline-block;
            padding: 5px 10px;
        }

        #switch-btn {
            position: absolute;
            bottom: 30px;
            right: 20px;
            z-index: 4;
            background-color: #333;
            color: white;
            border: 2px solid white;
            padding: 15px 20px;
            font-family: inherit;
            font-weight: bold;
            font-size: 1rem;
            cursor: pointer;
        }

        #start-overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.95);
            z-index: 10;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            cursor: pointer;
        }
        #start-btn {
            border: 2px solid #00FF00;
            padding: 20px;
            margin-top: 20px;
            font-size: 1.5rem;
            color: #00FF00;
        }
    </style>
    <!-- MediaPipe -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose/pose.js" crossorigin="anonymous"></script>
</head>
<body>
    <div class="container">
        <video id="input_video" class="mirror" playsinline autoplay muted></video>
        <canvas id="output_canvas" class="mirror"></canvas>
        
        <div id="status-box">
            <div id="message">WAITING...</div>
            <div id="debug"></div>
        </div>

        <button id="switch-btn">CAM SWITCH</button>

        <div id="start-overlay">
            <div style="text-align:center">UPLOAD 'pulling.mp3' & 'success.mp3'<br>BEFORE START</div>
            <div id="start-btn">TOUCH TO START</div>
        </div>
    </div>

    <script>
        const videoElement = document.getElementById('input_video');
        const canvasElement = document.getElementById('output_canvas');
        const canvasCtx = canvasElement.getContext('2d');
        const messageDiv = document.getElementById('message');
        const debugDiv = document.getElementById('debug');
        const switchBtn = document.getElementById('switch-btn');
        const startOverlay = document.getElementById('start-overlay');

        // Ïò§ÎîîÏò§ Í∞ùÏ≤¥ ÏÑ§Ï†ï
        const successAudioBase = new Audio('success.mp3');
        successAudioBase.load();
        
        const pullingAudioBase = new Audio('pulling.mp3'); 
        pullingAudioBase.volume = 0.75; // 75%Î°ú ÏÑ§Ï†ï
        pullingAudioBase.load();

        let lastSuccessState = false; // Ïù¥Ï†Ñ ÌîÑÎ†àÏûÑÏùò ÏÑ±Í≥µ ÏÉÅÌÉú Ï∂îÏ†Å
        let lastVibrationState = false; // Ïù¥Ï†Ñ ÏßÑÎèô ÏÉÅÌÉú (Ï¥àÎ°ùÏÉâ Ïó¨Î∂Ä)
        let isFrontCamera = true;
        let currentStream = null;
        let pose = null;
        let isRunning = false;

        // Î°úÏßÅ Î≥ÄÏàò
        let prevArmLength = 0; // Ïñ¥Íπ®-ÌåîÍøàÏπò Í±∞Î¶¨
        let lastPullTime = 0;

        // Ïä§Î¨¥Îî©ÏùÑ ÏúÑÌïú Î≥ÄÏàò
        let prevPostureScore = 0;
        let prevColor = "#FF0000";
        const SMOOTHING_FACTOR = 0.3; // 0~1, ÎÇÆÏùÑÏàòÎ°ù Î∂ÄÎìúÎü¨ÏõÄ (Ïù¥Ï†Ñ Í∞í ÏòÅÌñ• Ïª§Ïßê)

        function toPixel(landmark, width, height) {
            return { x: landmark.x * width, y: landmark.y * height };
        }

        // Îëê Ï†ê ÏÇ¨Ïù¥ Í±∞Î¶¨
        function getDistance(p1, p2) {
            return Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));
        }

        function calculateAngle(a, b, c) {
            const radians = Math.atan2(c.y - b.y, c.x - b.x) - Math.atan2(a.y - b.y, a.x - b.x);
            let angle = Math.abs(radians * 180.0 / Math.PI);
            if (angle > 180.0) angle = 360 - angle;
            return angle;
        }
        
        function calculateHorizontalDeviation(a, b) {
            const dy = b.y - a.y;
            const dx = b.x - a.x;
            let angle = Math.abs(Math.atan2(dy, dx) * 180.0 / Math.PI);
            if (angle > 90) angle = Math.abs(180 - angle);
            return angle;
        }

        // ÏÑ† Í∑∏Î¶¨Í∏∞
        function drawLine(ctx, p1, p2, color, width) {
            if (!p1 || !p2) return;
            ctx.beginPath();
            ctx.moveTo(p1.x, p1.y);
            ctx.lineTo(p2.x, p2.y);
            ctx.strokeStyle = color;
            ctx.lineWidth = width;
            ctx.stroke();
        }

        // Ï†ê Í∑∏Î¶¨Í∏∞
        function drawPoint(ctx, p, color, radius) {
            if (!p) return;
            ctx.beginPath();
            ctx.arc(p.x, p.y, radius, 0, 2 * Math.PI);
            ctx.fillStyle = color;
            ctx.fill();
        }

        // RGB ÏÉâÏÉÅ Î≥¥Í∞Ñ
        function interpolateColor(color1, color2, factor) {
            const r1 = parseInt(color1.slice(1, 3), 16);
            const g1 = parseInt(color1.slice(3, 5), 16);
            const b1 = parseInt(color1.slice(5, 7), 16);
            
            const r2 = parseInt(color2.slice(1, 3), 16);
            const g2 = parseInt(color2.slice(3, 5), 16);
            const b2 = parseInt(color2.slice(5, 7), 16);
            
            const r = Math.round(r1 + (r2 - r1) * factor);
            const g = Math.round(g1 + (g2 - g1) * factor);
            const b = Math.round(b1 + (b2 - b1) * factor);
            
            return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;
        }

        // Í∞í Ïä§Î¨¥Îî© (Ïù¥Ï†Ñ Í∞íÍ≥º ÌòÑÏû¨ Í∞íÏùò Í∞ÄÏ§ë ÌèâÍ∑†)
        function smoothValue(current, previous, factor) {
            return previous + (current - previous) * factor;
        }

        // ÏûêÏÑ∏ Ï†êÏàò Í≥ÑÏÇ∞ (0~1)
        function calculatePostureScore(lHorizon, rHorizon, lElbowAngle, rElbowAngle) {
            const ARM_HORIZON_LIMIT = 18;    // ÏàòÌèâ ÌóàÏö© Í∞ÅÎèÑ (15 ‚Üí 18)
            const ELBOW_STRAIGHT_MIN = 162;  // ÌåîÍøàÏπò Ìé¥Ïßê ÏµúÏÜå Í∞ÅÎèÑ (165 ‚Üí 162)
            
            const isLeftStraight = (lHorizon < ARM_HORIZON_LIMIT) && (lElbowAngle > ELBOW_STRAIGHT_MIN);
            const isRightStraight = (rHorizon < ARM_HORIZON_LIMIT) && (rElbowAngle > ELBOW_STRAIGHT_MIN);
            
            let score = 0;
            
            if (isLeftStraight && !isRightStraight) {
                // ÏôºÌåîÎßå ÏàòÌèâÏúºÎ°ú Ìé¥Ïßê - ÏôÑÎ≤Ω
                // ÏñºÎßàÎÇò ÏàòÌèâÏóê Í∞ÄÍπåÏö¥ÏßÄ
                const horizonScore = Math.max(0, 1 - lHorizon / ARM_HORIZON_LIMIT);
                // ÏñºÎßàÎÇò Ï≠â Ìé¥Ï°åÎäîÏßÄ
                const straightScore = Math.max(0, (lElbowAngle - ELBOW_STRAIGHT_MIN) / 18);
                score = (horizonScore * 0.5 + straightScore * 0.5);
            } else if (isRightStraight && !isLeftStraight) {
                // Ïò§Î•∏ÌåîÎßå ÏàòÌèâÏúºÎ°ú Ìé¥Ïßê - ÏôÑÎ≤Ω
                const horizonScore = Math.max(0, 1 - rHorizon / ARM_HORIZON_LIMIT);
                const straightScore = Math.max(0, (rElbowAngle - ELBOW_STRAIGHT_MIN) / 18);
                score = (horizonScore * 0.5 + straightScore * 0.5);
            } else if (isLeftStraight && isRightStraight) {
                // Îëò Îã§ Ìé¥Ïßê - Ï§ëÍ∞Ñ Ï†êÏàò (ÌïúÏ™ΩÎßå Ìé¥Ïïº Ìï®)
                score = 0.5;
            } else {
                // Îëò Îã§ Ïïà Ìé¥Ïßê - ÌåîÏùÑ Îì§Í≥† Ìé¥Îäî Ï†ïÎèÑÎ•º Î∂ÄÎìúÎüΩÍ≤å Ï†êÏàòÌôî
                // ÏôºÌåî ÏßÑÌñâÎèÑ
                const leftHorizonProgress = Math.max(0, Math.min(1, 1 - lHorizon / 60)); // 60ÎèÑ Î≤îÏúÑÏóêÏÑú Î∂ÄÎìúÎüΩÍ≤å
                const leftStraightProgress = Math.max(0, Math.min(1, lElbowAngle / 180)); // Ìé¥ÏßÄÎäî Ï†ïÎèÑ
                const leftScore = (leftHorizonProgress * 0.6 + leftStraightProgress * 0.4);
                
                // Ïò§Î•∏Ìåî ÏßÑÌñâÎèÑ
                const rightHorizonProgress = Math.max(0, Math.min(1, 1 - rHorizon / 60));
                const rightStraightProgress = Math.max(0, Math.min(1, rElbowAngle / 180));
                const rightScore = (rightHorizonProgress * 0.6 + rightStraightProgress * 0.4);
                
                // Îëò Ï§ë ÎÜíÏùÄ Ï™Ω ÏÑ†ÌÉù (Îçî ÏûòÌïòÎäî Ìåî Í∏∞Ï§Ä)
                score = Math.max(leftScore, rightScore) * 0.6; // ÏµúÎåÄ 60%ÍπåÏßÄÎßå
            }
            
            return Math.min(1, Math.max(0, score));
        }

        // Ï†êÏàòÏóê Îî∞Î•∏ ÏÉâÏÉÅ Î∞òÌôò
        function getColorByScore(score) {
            if (score >= 0.7) {
                // 0.7 Ïù¥ÏÉÅ: Ï¥àÎ°ùÏÉâ (Í∑∏ÎùºÎç∞Ïù¥ÏÖò ÏóÜÏù¥ Î∞îÎ°ú)
                return "#00FF00";
            } else if (score >= 0.15) {
                // 0.15~0.7: Îπ®Í∞ï -> Ìù∞ÏÉâ Í∑∏ÎùºÎç∞Ïù¥ÏÖò (Îçî ÎÑìÏùÄ Î≤îÏúÑ)
                const factor = (score - 0.15) / 0.55;
                return interpolateColor("#FF0000", "#FFFFFF", factor);
            } else {
                // 0~0.15: Îπ®Í∞ï
                return "#FF0000";
            }
        }

        // Í∞ÑÏÜåÌôîÎêú Ïä§Ìã±Îß® Í∑∏Î¶¨Í∏∞ (ÏÑ∏Î°ú ÏùºÏßÅÏÑ† Î™∏ÌÜµ)
        function drawStickFigure(ctx, p, mainColor, activeArm, isPulling) {
            const lineWidth = 6;
            
            let leftArmColor = mainColor;
            let rightArmColor = mainColor;

            // ÎãπÍ∏∞Îäî Ï§ëÏùº Îïå Ìï¥Îãπ Ìåî ÎÖ∏ÎûÄÏÉâ
            if (isPulling) {
                if (activeArm === 1) leftArmColor = "#FFFF00"; 
                if (activeArm === 2) rightArmColor = "#FFFF00"; 
            }

            // Î®∏Î¶¨
            if (p[0] && p[11] && p[12]) {
                const midShoulder = {x: (p[11].x + p[12].x) / 2, y: (p[11].y + p[12].y) / 2};
                drawLine(ctx, midShoulder, p[0], mainColor, lineWidth);
                // Î®∏Î¶¨ Ïõê
                drawPoint(ctx, p[0], mainColor, 15);
            }

            // Î™∏ÌÜµ ÏÑ∏Î°ú ÏùºÏßÅÏÑ† (Ïñ¥Íπ® Ï§ëÏ†ê -> Í≥®Î∞ò Ï§ëÏ†ê)
            if (p[11] && p[12] && p[23] && p[24]) {
                const midShoulder = {x: (p[11].x + p[12].x) / 2, y: (p[11].y + p[12].y) / 2};
                const midHip = {x: (p[23].x + p[24].x) / 2, y: (p[23].y + p[24].y) / 2};
                drawLine(ctx, midShoulder, midHip, mainColor, lineWidth);
                
                // Ïñ¥Íπ® Í∞ÄÎ°úÏÑ†
                drawLine(ctx, p[11], p[12], mainColor, lineWidth);
                // Í≥®Î∞ò Í∞ÄÎ°úÏÑ†
                drawLine(ctx, p[23], p[24], mainColor, lineWidth);
            }

            // ÏôºÌåî
            if (p[11] && p[13] && p[15]) {
                drawLine(ctx, p[11], p[13], leftArmColor, lineWidth);
                drawLine(ctx, p[13], p[15], leftArmColor, lineWidth);
            }
            // Ïò§Î•∏Ìåî
            if (p[12] && p[14] && p[16]) {
                drawLine(ctx, p[12], p[14], rightArmColor, lineWidth);
                drawLine(ctx, p[14], p[16], rightArmColor, lineWidth);
            }

            // ÏôºÎã§Î¶¨
            if (p[23] && p[25] && p[27]) {
                drawLine(ctx, p[23], p[25], mainColor, lineWidth);
                drawLine(ctx, p[25], p[27], mainColor, lineWidth);
            }
            // Ïò§Î•∏Îã§Î¶¨
            if (p[24] && p[26] && p[28]) {
                drawLine(ctx, p[24], p[26], mainColor, lineWidth);
                drawLine(ctx, p[26], p[28], mainColor, lineWidth);
            }
        }

        // ÏÜêÍ∞ÄÎùΩ Í∑∏Î¶¨Í∏∞
        function drawHand(ctx, handLandmarks, color, width, height) {
            if (!handLandmarks) return;
            
            const points = handLandmarks.map(lm => toPixel(lm, width, height));
            const lineWidth = 3;
            const pointRadius = 4;

            // ÏÜêÍ∞ÄÎùΩ Ïó∞Í≤∞ÏÑ† Ï†ïÏùò (MediaPipe Hands landmark Íµ¨Ï°∞)
            const fingerConnections = [
                // ÏóÑÏßÄ
                [0, 1], [1, 2], [2, 3], [3, 4],
                // Í≤ÄÏßÄ
                [0, 5], [5, 6], [6, 7], [7, 8],
                // Ï§ëÏßÄ
                [0, 9], [9, 10], [10, 11], [11, 12],
                // ÏïΩÏßÄ
                [0, 13], [13, 14], [14, 15], [15, 16],
                // ÏÜåÏßÄ
                [0, 17], [17, 18], [18, 19], [19, 20],
                // ÏÜêÎ∞îÎã•
                [5, 9], [9, 13], [13, 17]
            ];

            // ÏÑ† Í∑∏Î¶¨Í∏∞
            fingerConnections.forEach(([i, j]) => {
                drawLine(ctx, points[i], points[j], color, lineWidth);
            });

            // Í¥ÄÏ†à Ìè¨Ïù∏Ìä∏ Í∑∏Î¶¨Í∏∞
            points.forEach(p => {
                drawPoint(ctx, p, color, pointRadius);
            });
        }

        function playSuccessSound() {
            const sound = successAudioBase.cloneNode();
            sound.volume = 1.0;
            sound.play().catch(e => console.log("Success audio play failed:", e));
        }

        function playPullingSound() {
            const sound = pullingAudioBase.cloneNode();
            sound.volume = 0.75;
            sound.play().catch(e => console.log("Pulling audio play failed:", e));
        }

        // ÏßßÏùÄ ÏßÑÎèô (50msÎ°ú Ï¶ùÍ∞Ä, ÎîîÎ≤ÑÍπÖ Î°úÍ∑∏ Ï∂îÍ∞Ä)
        function triggerVibration() {
            console.log("üîî Vibration triggered!");
            if ('vibrate' in navigator) {
                try {
                    const success = navigator.vibrate(50); // 30ms ‚Üí 50msÎ°ú Ï¶ùÍ∞Ä
                    console.log("Vibration result:", success);
                } catch (e) {
                    console.error("Vibration error:", e);
                }
            } else {
                console.log("Vibration API not supported");
            }
        }

        function onPoseResults(results) {
            if (!isRunning) return;

            const width = videoElement.videoWidth;
            const height = videoElement.videoHeight;
            canvasElement.width = width;
            canvasElement.height = height;

            canvasCtx.save();
            canvasCtx.clearRect(0, 0, width, height);

            if (results.poseLandmarks) {
                const rawLm = results.poseLandmarks;
                const p = {};
                // ÌïÑÏöîÌïú Ìè¨Ïù∏Ìä∏Îì§ ÌôïÏû•
                [0, 11,12,13,14,15,16,23,24,25,26,27,28].forEach(idx => {
                    if(rawLm[idx]) p[idx] = toPixel(rawLm[idx], width, height);
                });

                const ARM_HORIZON_LIMIT = 18;    
                const ELBOW_STRAIGHT_MIN = 162;  

                let isSuccess = false;
                let failReason = "";
                let activeArm = 0; // 1:ÏôºÏ™Ω, 2:Ïò§Î•∏Ï™Ω
                let isPulling = false; 
                let postureScore = 0;

                if(p[11] && p[12] && p[13] && p[14] && p[15] && p[16] && p[23] && p[24]) {
                    
                    const lHorizon = calculateHorizontalDeviation(p[11], p[15]);
                    const rHorizon = calculateHorizontalDeviation(p[12], p[16]);
                    const lElbowAngle = calculateAngle(p[11], p[13], p[15]);
                    const rElbowAngle = calculateAngle(p[12], p[14], p[16]);

                    const isLeftStraight = (lHorizon < ARM_HORIZON_LIMIT) && (lElbowAngle > ELBOW_STRAIGHT_MIN);
                    const isRightStraight = (rHorizon < ARM_HORIZON_LIMIT) && (rElbowAngle > ELBOW_STRAIGHT_MIN);

                    // ÏûêÏÑ∏ Ï†êÏàò Í≥ÑÏÇ∞
                    postureScore = calculatePostureScore(lHorizon, rHorizon, lElbowAngle, rElbowAngle);
                    
                    // Ïä§Î¨¥Îî© Ï†ÅÏö© (Îñ®Î¶º Î∞©ÏßÄ)
                    postureScore = smoothValue(postureScore, prevPostureScore, SMOOTHING_FACTOR);
                    prevPostureScore = postureScore;

                    if (isLeftStraight && !isRightStraight) {
                        isSuccess = true;
                        activeArm = 2; // ÏôºÌåîÏù¥ Ìé¥Ïßê ‚Üí Í±∞Ïö∏Î™®ÎìúÏóêÏÑúÎäî Ïò§Î•∏Ï™ΩÏúºÎ°ú Î≥¥ÏûÑ
                    } else if (isRightStraight && !isLeftStraight) {
                        isSuccess = true;
                        activeArm = 1; // Ïò§Î•∏ÌåîÏù¥ Ìé¥Ïßê ‚Üí Í±∞Ïö∏Î™®ÎìúÏóêÏÑúÎäî ÏôºÏ™ΩÏúºÎ°ú Î≥¥ÏûÑ
                    } else if (isLeftStraight && isRightStraight) {
                        failReason = "USE ONLY ONE ARM";
                    } else {
                        failReason = "RAISE ONE ARM STRAIGHT";
                    }
                }

                // Ï†êÏàòÏóê Îî∞Î•∏ ÏÉâÏÉÅ
                let currentColor = getColorByScore(postureScore);
                
                // ÏÉâÏÉÅ Ïä§Î¨¥Îî© (Í∏âÍ≤©Ìïú ÏÉâÏÉÅ Î≥ÄÌôî Î∞©ÏßÄ)
                let color = interpolateColor(prevColor, currentColor, SMOOTHING_FACTOR * 2); // ÏÉâÏÉÅÏùÄ Ï°∞Í∏à Îçî Îπ†Î•¥Í≤å
                prevColor = color;

                // ÏÑ±Í≥µ Ï°∞Í±¥: Ï†êÏàò 0.7 Ïù¥ÏÉÅ
                if (postureScore >= 0.7 && isSuccess) {
                    messageDiv.innerText = "PULL BACK!";
                    
                    // Ïù¥Ï†ÑÏóê Ïã§Ìå® ÏÉÅÌÉúÏòÄÎã§Í∞Ä ÏÑ±Í≥µ ÏÉÅÌÉúÎ°ú Î∞îÎÄåÏóàÏùÑ ÎïåÎßå success ÏÇ¨Ïö¥Îìú Ïû¨ÏÉù
                    if (!lastSuccessState) {
                        playSuccessSound();
                    }
                    lastSuccessState = true;
                    lastVibrationState = true; // Ï¥àÎ°ùÏÉâ ÏÉÅÌÉú Í∏∞Î°ù

                    // Ïñ¥Íπ®-ÌåîÍøàÏπò ÏÑ†Ïùò Í∏∏Ïù¥ ÏßßÏïÑÏßê Í∞êÏßÄ
                    let currentArmLength = 0;
                    
                    // Ìé¥ÏßÑ Ìåî(activeArm)Ïùò Ïñ¥Íπ®-ÌåîÍøàÏπò Í±∞Î¶¨ Ï∏°Ï†ï
                    if (activeArm === 1) { // ÏôºÌåîÏù¥ Ìé¥Ïßê
                        currentArmLength = getDistance(p[11], p[13]); // ÏôºÏ™Ω Ïñ¥Íπ®-ÌåîÍøàÏπò
                    } else if (activeArm === 2) { // Ïò§Î•∏ÌåîÏù¥ Ìé¥Ïßê
                        currentArmLength = getDistance(p[12], p[14]); // Ïò§Î•∏Ï™Ω Ïñ¥Íπ®-ÌåîÍøàÏπò
                    }

                    if (prevArmLength > 0) {
                        const diff = prevArmLength - currentArmLength;

                        if (diff > 0.3) {
                            isPulling = true;
                            
                            const now = Date.now();
                            let delay = Math.max(50, 400 - (diff * 100)); 

                            if (now - lastPullTime > delay) {
                                playPullingSound();
                                lastPullTime = now;
                            }
                            debugDiv.innerText = `SHORTENING: ${diff.toFixed(2)}`;
                        } else if (diff < -0.3) {
                            debugDiv.innerText = "EXTENDING...";
                        } else {
                            debugDiv.innerText = "HOLDING...";
                        }
                    } else {
                        debugDiv.innerText = "READY";
                    }

                    prevArmLength = currentArmLength;

                } else {
                    messageDiv.innerText = failReason || "CHECK POSTURE";
                    
                    // Ï¥àÎ°ùÏÉâ(ÏÑ±Í≥µ)ÏóêÏÑú Ìù∞ÏÉâ/Îπ®Í∞ï(Ïã§Ìå®)ÏúºÎ°ú Ï†ÑÌôò Ïãú ÏßÑÎèô
                    if (lastVibrationState) {
                        triggerVibration(); // Ï¥àÎ°ùÏÉâ ‚Üí Ìù∞ÏÉâ/Îπ®Í∞ï Ï†ÑÌôò Ïãú ÏßÑÎèô!
                        console.log("üü¢‚Üí‚ö™ State change detected - vibrating");
                    }
                    
                    // Ïã§ÏãúÍ∞Ñ Í∞ÅÎèÑ Ï†ïÎ≥¥ ÌëúÏãú
                    if (p[11] && p[12] && p[13] && p[14] && p[15] && p[16]) {
                        const lHorizon = calculateHorizontalDeviation(p[11], p[15]);
                        const rHorizon = calculateHorizontalDeviation(p[12], p[16]);
                        const lElbowAngle = calculateAngle(p[11], p[13], p[15]);
                        const rElbowAngle = calculateAngle(p[12], p[14], p[16]);
                        debugDiv.innerText = `SCORE: ${(postureScore * 100).toFixed(0)}% | L:${lElbowAngle.toFixed(0)}¬∞ R:${rElbowAngle.toFixed(0)}¬∞`;
                    } else {
                        debugDiv.innerText = `SCORE: ${(postureScore * 100).toFixed(0)}%`;
                    }

                    lastSuccessState = false;
                    lastVibrationState = false; // Ï¥àÎ°ùÏÉâ ÏïÑÎãò ‚Üí ÏßÑÎèô ÏÉÅÌÉú Î¶¨ÏÖã
                    prevArmLength = 0;
                }

                drawStickFigure(canvasCtx, p, color, activeArm, isPulling);
            }
            canvasCtx.restore();
        }

        async function setupCamera() {
            if (currentStream) currentStream.getTracks().forEach(track => track.stop());
            const constraints = {
                video: { width: { ideal: 1280 }, height: { ideal: 720 }, facingMode: isFrontCamera ? 'user' : 'environment' },
                audio: false
            };
            try {
                const stream = await navigator.mediaDevices.getUserMedia(constraints);
                currentStream = stream;
                videoElement.srcObject = stream;
                if (isFrontCamera) { videoElement.className = 'mirror'; canvasElement.className = 'mirror'; } 
                else { videoElement.className = 'normal'; canvasElement.className = 'normal'; }
                return new Promise((resolve) => { videoElement.onloadedmetadata = () => { resolve(videoElement); }; });
            } catch (err) { alert("Camera Error: " + err.message); }
        }

        async function renderFrame() {
            if (!videoElement.paused && !videoElement.ended) { 
                await pose.send({image: videoElement});
            }
            requestAnimationFrame(renderFrame);
        }

        async function initPose() {
            messageDiv.innerText = "LOADING...";
            
            // Pose Ï¥àÍ∏∞Ìôî
            pose = new Pose({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/pose/${file}`});
            pose.setOptions({ 
                modelComplexity: 1, 
                smoothLandmarks: true,
                minDetectionConfidence: 0.7,  // 0.5 ‚Üí 0.7 (Îçî ÌôïÏã§Ìïú Í∞êÏßÄÎßå)
                minTrackingConfidence: 0.7    // 0.5 ‚Üí 0.7 (Îçî ÏïàÏ†ïÏ†ÅÏù∏ Ï∂îÏ†Å)
            });
            pose.onResults(onPoseResults);

            await setupCamera();
            videoElement.play();
            renderFrame();
            messageDiv.innerText = "READY";
        }

        // ÏãúÏûë Î≤ÑÌäº ÌÅ¥Î¶≠ Ïãú Ïò§ÎîîÏò§ Í∂åÌïú ÌöçÎìù
        startOverlay.addEventListener('click', () => {
            startOverlay.style.display = 'none';
            isRunning = true;
            
            // ÏßÑÎèô ÌÖåÏä§Ìä∏ (Í∂åÌïú ÌöçÎìù)
            if ('vibrate' in navigator) {
                navigator.vibrate(50);
                console.log("Initial vibration test");
            }
            
            // Î™®Î∞îÏùº Î∏åÎùºÏö∞Ï†Ä Îì±Ïùò Ï†ïÏ±ÖÏùÑ Ïö∞ÌöåÌïòÍ∏∞ ÏúÑÌï¥ Îπà ÏÜåÎ¶¨ Ïû¨ÏÉù ÏãúÎèÑ
            successAudioBase.play().then(()=>successAudioBase.pause()).catch(()=>{});
            pullingAudioBase.play().then(()=> {
                pullingAudioBase.pause();
                pullingAudioBase.currentTime = 0;
            }).catch((e)=>{console.log("Init audio failed", e)});

            initPose();
        });

        switchBtn.addEventListener('click', async () => {
            isFrontCamera = !isFrontCamera;
            switchBtn.innerText = "LOADING...";
            await setupCamera();
            videoElement.play();
            switchBtn.innerText = "CAM SWITCH";
        });
    </script>
</body>
</html>
